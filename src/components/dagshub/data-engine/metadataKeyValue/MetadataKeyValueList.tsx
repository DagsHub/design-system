import React, { useEffect, useRef, useState } from 'react';
import Box from '@mui/material/Box';
import { MetadataKeyValuePair } from './MetadataKeyValuePair';
import StyledTextField from './StyledTextField';
import IconButton from '@mui/material/IconButton';
import AddIcon from '@mui/icons-material/Add';
import { Button, ButtonStretch, ButtonVariant } from '../../../elements';

export type MetadataType = 'BOOLEAN' | 'INTEGER' | 'FLOAT' | 'STRING' | 'BLOB';

//The format used for managing the metadata list in the component
export interface NewMetadataField {
  key?: string;
  value?: string;
  valueType?: MetadataType;
  multiple?: boolean;
  isAutoGenerated?: boolean;
  isNewlyCreated?: boolean;
}

//The format the component expects to receive the metadata list
export interface MetadataField {
  key: string;
  value: string;
  valueType: MetadataType;
  multiple?: boolean;
  isAutoGenerated?: boolean;
}

//The format the component returns the metadata list
export interface DatapointMetadataInput {
  datapointId?: number;
  url?: string;
  key: string;
  value: string;
  valueType: MetadataType;
  allowMultiple?: boolean;
}

export interface MetadataKeyValueListProps {
  maxHeight?: string;
  metadataList: MetadataField[];
  onDeleteHandler?: (keyName: string) => void;
  onSaveHandler?: (metadataList: DatapointMetadataInput[]) => void;
  validateValueByType?: (valueType: MetadataType, value: string) => boolean;
}

export function MetadataKeyValueList({
  maxHeight,
  metadataList,
  onDeleteHandler,
  onSaveHandler,
  validateValueByType,
}: MetadataKeyValueListProps) {
  //Todo:
  // - Not sure what to do with the multiple field. (If I need to use it as part of the validations in the future, and also what value should I set for newly created fields).
  // - Validations that are missing:
  //  * Check whether new field created was left empty
  //  * When edit/ creating new keys, make sure the value match the value type.
  //  * When creating new keys, make sure that the new key name doesn't already exist.
  // - Not sure yet how the external save progress should work. For now, whenever I'm saving changes locally, I'm calling the external 'onChangeHandler' func.
  //    Whoever use this component will have external save button.
  // - The deletion of existing metadata field doesnt depend on the external save button.

  const [temporaryMetadataList, setTemporaryMetadataList] = useState<NewMetadataField[]>([
    ...metadataList,
  ]);
  const metadataFieldsSection = useRef(null);
  const [shouldHighlightEmptyFields, setShouldHighlightEmptyFields] = useState(false);
  const [autoFocusNewlyCreatedFieldKey, setAutoFocusNewlyCreatedFieldKey] = useState(true);
  const [shouldScrollToBottom, setShouldScrollToBottom] = useState<boolean>(false); //Should scroll to bottom only after adding new field
  const [showButtonsSection, setShowButtonsSection] = useState<boolean>(false);

  const checkIfTemporaryMetadataListIsEqualToOriginalMetadataList = () => {
    //Compare the fields - if isNewlyCreated is undefined and all the rest are the same, it means its equal, if there is metadat with isNewlyCreated true, its not equal
    if(temporaryMetadataList.length !== metadataList.length) return false;
    return temporaryMetadataList.every((tempField, index) => {
      const originalField = metadataList[index];
      return (
        tempField.isAutoGenerated === originalField.isAutoGenerated &&
        tempField.key === originalField.key &&
        tempField.value === originalField.value &&
        tempField.valueType === originalField.valueType &&
        !tempField.isNewlyCreated
      );
    });
  }

  useEffect(()=>{
    setShowButtonsSection(!checkIfTemporaryMetadataListIsEqualToOriginalMetadataList());
  },[temporaryMetadataList, metadataList])

  useEffect(() => {
    setTemporaryMetadataList([...metadataList]);
    if (metadataFieldsSection.current) {
      (metadataFieldsSection.current as HTMLDivElement).scrollTop = 0;
    }
  }, [metadataList]);

  const convertNewMetadataFieldToDatapointMetadataInput = (
    metadataList: NewMetadataField[]
  ): DatapointMetadataInput[] => {
    return metadataList.map((metadataField) => {
      return {
        key: metadataField.key as string,
        value: metadataField.value as string,
        valueType: metadataField.valueType as MetadataType,
        allowMultiple: !!metadataField.multiple,
      };
    });
  };

  useEffect(() => {
    if (shouldScrollToBottom && metadataFieldsSection.current) {
      // scroll to button only if + button was clicked
      (metadataFieldsSection.current as HTMLDivElement).scrollTop = (
        metadataFieldsSection.current as HTMLDivElement
      ).scrollHeight;
      setShouldScrollToBottom(false); //turn it off after scrolling
    }
    setAutoFocusNewlyCreatedFieldKey(true); //highlight again when the user adds new field
  }, [temporaryMetadataList]);

  useEffect(() => {
    if (shouldHighlightEmptyFields) {
      setTimeout(() => {
        setShouldHighlightEmptyFields(false);
      }, 1000);
    }
  }, [shouldHighlightEmptyFields]);

  const CheckIfEmptyFieldsAndHighlightThem = () => {
    const hasEmptyFields = temporaryMetadataList.some((field) => {
      return (
        field.key === undefined ||
        field.key == '' ||
        field.value === undefined ||
        field.value === '' ||
        field.valueType === undefined
      );
    });

    setShouldHighlightEmptyFields(hasEmptyFields);
    return hasEmptyFields;
  };

  const handleAddNew = () => {
    setShouldScrollToBottom(true); //scroll to button when clicking on the + button
    const hasEmptyFields = CheckIfEmptyFieldsAndHighlightThem();
    if (!hasEmptyFields) {
      //if there are no empty fields, add new field
      const newField: NewMetadataField = {
        key: undefined,
        value: '',
        valueType: undefined,
        multiple: false,
        isAutoGenerated: undefined,
        isNewlyCreated: true,
      };
      setTemporaryMetadataList((prevList) => [...prevList, newField]);
    }
  };

  const locallyEditKeyAtIndex = (index: number, newKey: string | undefined) => {
    if (temporaryMetadataList[index].isNewlyCreated) {
      setAutoFocusNewlyCreatedFieldKey(false);
    }
    setTemporaryMetadataList((prevList) => {
      const newList = [...prevList];
      newList[index] = { ...newList[index], key: newKey };
      return newList;
    });
  };

  const locallyEditValueAtIndex = (index: number, newValue: string | undefined) => {
    setTemporaryMetadataList((prevList) => {
      const newList = [...prevList];
      newList[index] = { ...newList[index], value: newValue };
      return newList;
    });
  };

  const locallyEditValueTypeAtIndex = (index: number, newType: MetadataType | undefined) => {
    setTemporaryMetadataList((prevList) => {
      const newList = [...prevList];
      newList[index] = { ...newList[index], valueType: newType };
      return newList;
    });
  };

  const locallyRemoveMetadataFieldByIndex = (indexToRemove: number) => {
    if (temporaryMetadataList[indexToRemove].isNewlyCreated) {
      setAutoFocusNewlyCreatedFieldKey(true); //stop highlighting the edited field
    }
    setTemporaryMetadataList((prevList) => {
      const newList = prevList.filter((_, index) => index !== indexToRemove);
      return newList;
    });
  };

  const permanentlyDeleteMetadataFieldByIndex = (indexToRemove: number) => {
    if (onDeleteHandler) {
      try {
        onDeleteHandler(metadataList[indexToRemove].key);
        setTemporaryMetadataList((prevList) => {
          const newList = prevList.filter((_, index) => index !== indexToRemove);
          return newList;
        });
      } catch (e) {}
    }
  };

  const checkIfPairIsRemovable = (metadataField: {
    key?: string;
    value?: string;
    valueType?: MetadataType;
    multiple?: boolean;
    isAutoGenerated?: boolean;
    isNewlyCreated?: boolean;
  }) => {
    if (!!onSaveHandler && metadataField.isNewlyCreated) {
      //it should always be possible to delete newly created fields, even if deletion is not enabled
      return true;
    }
    if (!!onDeleteHandler && !metadataField.isAutoGenerated) {
      //logic for pre-existing fields
      return true;
    }
    return false;
  };

  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        height: '100%',
        maxHeight: maxHeight ?? '100%',
        overflowX: 'hidden',
      }}
    >
      <Box
        ref={metadataFieldsSection}
        sx={{
          display: 'flex',
          flexDirection: 'column',
          height: '100%',
          maxHeight: '100%',
          overflowY: 'auto',
          overflowX: 'hidden',
        }}
      >
        {temporaryMetadataList.map((metadataField, index) => (
          <MetadataKeyValuePair
            {...metadataField}
            index={index}
            keyName={metadataField.key}
            value={String(metadataField.value)}
            isEditable={!!onSaveHandler && !metadataField.isAutoGenerated}
            description={metadataField.isAutoGenerated ? 'Auto-generated' : undefined}
            isRemovable={checkIfPairIsRemovable(metadataField)}
            saveKeyNameLocally={locallyEditKeyAtIndex}
            saveValueTypeLocally={locallyEditValueTypeAtIndex}
            saveValueLocally={locallyEditValueAtIndex}
            shouldHighlightEmptyFields={shouldHighlightEmptyFields}
            deleteFieldPermanently={
              metadataField.isNewlyCreated
                ? locallyRemoveMetadataFieldByIndex
                : permanentlyDeleteMetadataFieldByIndex
            }
            autoFocusKey={metadataField.isNewlyCreated && autoFocusNewlyCreatedFieldKey}
            validateValueByType={validateValueByType}
          />
        ))}
      </Box>
      {!!onSaveHandler && (
        <>
          <StyledTextField
            onClick={handleAddNew}
            sx={{
              borderBottom: '1px solid #E2E8F0',
              borderRadius: 0,
            }}
            focusModeDisabled
            changeColorOnHover
            InputProps={{
              sx: { input: { cursor: 'pointer!important' } },
              readOnly: true,
              endAdornment: (
                <IconButton>
                  <AddIcon />
                </IconButton>
              ),
            }}
            value={'Add new'}
          />
          {showButtonsSection && <Box
            sx={{
              padding: '16px',
              display: 'flex',
              width: '100%',
              gap: '8px',
              justifyContent: 'flex-end',
            }}
          >
            <Button
              variant={ButtonVariant.Secondary}
              style={{ borderRadius: '8px' }}
              label={'Cancel'}
              stretch={ButtonStretch.Slim}
              onClick={() => {
                // onResetChanges();
                //Todo: implement
              }}
            />
            <Button
              style={{ borderRadius: '8px' }}
              label={'Save'}
              stretch={ButtonStretch.Slim}
              disabled={false} //Todo
              onClick={() => {
                onSaveHandler(
                  convertNewMetadataFieldToDatapointMetadataInput(temporaryMetadataList)
                );
              }}
            />
          </Box>}
        </>
      )}
    </Box>
  );
}
