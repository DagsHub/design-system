import React, { useEffect, useRef, useState } from 'react';
import Box from '@mui/material/Box';
import { MetadataKeyValuePair } from './MetadataKeyValuePair';
import StyledTextField from './StyledTextField';
import IconButton from '@mui/material/IconButton';
import AddIcon from '@mui/icons-material/Add';

export interface MetadataKeyValueListProps {
  maxMetadataFieldsSectionHeight?: string;
  metadataList: {
    key: string;
    value: string;
    valueType: string;
    multiple: boolean;
    isAutoGenerated?: boolean;
  }[];
  isEditable: boolean;
  deletionEnabled: boolean;
  onDeleteHandler?: (keyName:string)=>void;
  onChangeHandler: (
    metadataList: {
      key?: string;
      value?: string;
      valueType?: string;
      multiple: boolean;
      isAutoGenerated?: boolean;
    }[]
  ) => void;
}

export function MetadataKeyValueList({
  maxMetadataFieldsSectionHeight,
  metadataList,
  isEditable,
  deletionEnabled,
  onDeleteHandler,
  onChangeHandler
}: MetadataKeyValueListProps) {
  //Todo:
  // - Not sure what to do with the multiple field. (If I need to use it as part of the validations in the future, and also what value should I set for newly created fields).
  // - Validations that are missing:
  //  * Check whether new field created was left empty
  //  * When edit/ creating new keys, make sure the value match the value type.
  //  * When creating new keys, make sure that the new key name doesn't already exist.
  // - Not sure yet how the external save progress should work. For now, whenever I'm saving changes locally, I'm calling the external 'onChangeHandler' func.
  //    Whoever use this component will have external save button.
  // - The deletion of existing metadata field is immediate, and do not depend on the external save button

  const [temporaryMetadataList, setTemporaryMetadataList] = useState<
    {
      key?: string;
      value?: string;
      valueType?: string;
      multiple: boolean;
      isAutoGenerated?: boolean;
      isNewlyCreated?: boolean;
    }[]
  >([...metadataList]);
  const metadataFieldsSection = useRef(null);

  useEffect(() => {
    onChangeHandler({ ...temporaryMetadataList });
    if (metadataFieldsSection.current) {
      (metadataFieldsSection.current as HTMLDivElement).scrollTop = (
        metadataFieldsSection.current as HTMLDivElement
      ).scrollHeight;
    }
  }, [temporaryMetadataList]);

  const handleAddNew = () => {
    const newField = { multiple: false, isNewlyCreated: true };
    setTemporaryMetadataList((prevList) => [...prevList, newField]);
    // Scroll to the bottom of the metadata fields box, whenever "add new" button is clicked
    if (metadataFieldsSection.current) {
      (metadataFieldsSection.current as HTMLDivElement).scrollTop = (
        metadataFieldsSection.current as HTMLDivElement
      ).scrollHeight;
    }
  };

  const locallyEditKeyAtIndex = (index: number, newKey: string | undefined) => {
    setTemporaryMetadataList((prevList) => {
      const newList = [...prevList];
      newList[index] = { ...newList[index], key: newKey };
      return newList;
    });
  };

  const locallyEditValueAtIndex = (index: number, newValue: string | undefined) => {
    setTemporaryMetadataList((prevList) => {
      const newList = [...prevList];
      newList[index] = { ...newList[index], value: newValue };
      return newList;
    });
  };

  const locallyEditValueTypeAtIndex = (index: number, newType: string | number | undefined) => {
    setTemporaryMetadataList((prevList) => {
      const newList = [...prevList];
      newList[index] = { ...newList[index], valueType: newType as string };
      return newList;
    });
  };

  const locallyRemoveMetadataFieldByIndex = (indexToRemove: number) => {
    setTemporaryMetadataList((prevList) => {
      const newList = prevList.filter((_, index) => index !== indexToRemove);
      return newList;
    });
  };

  const permanentlyDeleteMetadataFieldByIndex = (indexToRemove: number) => {
    setTemporaryMetadataList((prevList) => {
      const newList = prevList.filter((_, index) => index !== indexToRemove);
      return newList;
    });
    if(onDeleteHandler){
      onDeleteHandler(metadataList[indexToRemove].key)
    }
  };

  return (
    <Box>
      <Box
        ref={metadataFieldsSection}
        sx={{ maxHeight: maxMetadataFieldsSectionHeight, overflowY: 'auto' }}
      >
        {temporaryMetadataList.map((value, index) => (
          <MetadataKeyValuePair
            {...value}
            index={index}
            keyName={value.key}
            isEditable={isEditable}
            deletionEnabled={isEditable && deletionEnabled && !!onDeleteHandler}
            saveKeyNameLocally={locallyEditKeyAtIndex}
            saveValueTypeLocally={locallyEditValueTypeAtIndex}
            saveValueLocally={locallyEditValueAtIndex}
            deleteFieldPermanently={value.isNewlyCreated?locallyRemoveMetadataFieldByIndex:permanentlyDeleteMetadataFieldByIndex}
          />
        ))}
      </Box>
      {isEditable && (
        <StyledTextField
          style={{
            borderBottom: '1px solid #E2E8F0',
            borderRadius: 0,
            height: '100%',
            pointerEvents: 'none'
          }}
          changeColorOnHover
          InputProps={{
            readOnly: true,
            endAdornment: (
              <IconButton style={{ pointerEvents: 'all' }} onClick={handleAddNew}>
                <AddIcon />
              </IconButton>
            )
          }}
          value={'Add new'}
        />
      )}
    </Box>
  );
}
